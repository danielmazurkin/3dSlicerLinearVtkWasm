import createWebWorkerPromise from '../core/createWebWorkerPromise.js';
import loadEmscriptenModuleMainThread from '../core/internal/loadEmscriptenModuleMainThread.js';
import config from '../itkConfig.js';
import IOTypes from '../core/IOTypes.js';
import InterfaceTypes from '../core/InterfaceTypes.js';
import runPipelineEmscripten from './internal/runPipelineEmscripten.js';
import getTransferable from '../core/getTransferable.js';
// To cache loaded pipeline modules
const pipelineToModule = new Map();
async function loadPipelineModule(pipelinePath) {
    let moduleRelativePathOrURL = pipelinePath;
    let pipeline = pipelinePath;
    if (typeof pipelinePath !== 'string') {
        moduleRelativePathOrURL = new URL(pipelinePath.href);
        pipeline = moduleRelativePathOrURL.href;
    }
    if (pipelineToModule.has(pipeline)) {
        return pipelineToModule.get(pipeline);
    }
    else {
        const pipelineModule = (await loadEmscriptenModuleMainThread(pipelinePath, config.pipelinesUrl));
        pipelineToModule.set(pipeline, pipelineModule);
        return pipelineModule;
    }
}
async function runPipeline(webWorker, pipelinePath, args, outputs, inputs, options) {
    var _a;
    if (webWorker === false) {
        const pipelineModule = await loadPipelineModule(pipelinePath.toString());
        const result = runPipelineEmscripten(pipelineModule, args, outputs, inputs);
        return result;
    }
    let worker = webWorker;
    const pipelineWorkerUrl = options === null || options === void 0 ? void 0 : options.pipelineWorkerUrl;
    const pipelineWorkerUrlString = typeof pipelineWorkerUrl !== 'string' && typeof (pipelineWorkerUrl === null || pipelineWorkerUrl === void 0 ? void 0 : pipelineWorkerUrl.href) !== 'undefined' ? pipelineWorkerUrl.href : pipelineWorkerUrl;
    const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise(worker, pipelineWorkerUrlString);
    worker = usedWorker;
    const transferables = [];
    if (!(inputs == null) && inputs.length > 0) {
        inputs.forEach(function (input) {
            if (input.type === InterfaceTypes.BinaryStream) {
                // Binary data
                const dataArray = input.data.data;
                const transferable = getTransferable(dataArray);
                if (transferable != null) {
                    transferables.push(transferable);
                }
            }
            else if (input.type === InterfaceTypes.BinaryFile) {
                // Binary data
                const dataArray = input.data.data;
                const transferable = getTransferable(dataArray);
                if (transferable != null) {
                    transferables.push(transferable);
                }
            }
            else if (input.type === InterfaceTypes.Image) {
                // Image data
                const image = input.data;
                if (image.data === null) {
                    throw Error('image data cannot be null');
                }
                let transferable = getTransferable(image.data);
                if (transferable != null) {
                    transferables.push(transferable);
                }
                transferable = getTransferable(image.direction);
                if (transferable != null) {
                    transferables.push(transferable);
                }
            }
            else if (input.type === IOTypes.Binary) {
                // Binary data
                const transferable = getTransferable(input.data);
                if (transferable != null) {
                    transferables.push(transferable);
                }
            }
            else if (input.type === IOTypes.Image) {
                // Image data
                const image = input.data;
                if (image.data === null) {
                    throw Error('image data cannot be null');
                }
                let transferable = getTransferable(image.data);
                if (transferable != null) {
                    transferables.push(transferable);
                }
                transferable = getTransferable(image.direction);
                if (transferable != null) {
                    transferables.push(transferable);
                }
            }
            else if (input.type === IOTypes.Mesh) {
                // Mesh data
                const mesh = input.data;
                if (mesh.points != null) {
                    const transferable = getTransferable(mesh.points);
                    if (transferable != null) {
                        transferables.push(transferable);
                    }
                }
                if (mesh.pointData != null) {
                    const transferable = getTransferable(mesh.pointData);
                    if (transferable != null) {
                        transferables.push(transferable);
                    }
                }
                if (mesh.cells != null) {
                    const transferable = getTransferable(mesh.cells);
                    if (transferable != null) {
                        transferables.push(transferable);
                    }
                }
                if (mesh.cellData != null) {
                    const transferable = getTransferable(mesh.cellData);
                    if (transferable != null) {
                        transferables.push(transferable);
                    }
                }
            }
        });
    }
    const pipelineBaseUrl = (_a = options === null || options === void 0 ? void 0 : options.pipelineBaseUrl) !== null && _a !== void 0 ? _a : 'pipelinesUrl';
    const pipelineBaseUrlString = typeof pipelineBaseUrl !== 'string' && typeof (pipelineBaseUrl === null || pipelineBaseUrl === void 0 ? void 0 : pipelineBaseUrl.href) !== 'undefined' ? pipelineBaseUrl.href : pipelineBaseUrl;
    const result = await webworkerPromise.postMessage({
        operation: 'runPipeline',
        config: config,
        pipelinePath: pipelinePath.toString(),
        pipelineBaseUrl: pipelineBaseUrlString,
        args,
        outputs,
        inputs
    }, transferables);
    return {
        returnValue: result.returnValue,
        stdout: result.stdout,
        stderr: result.stderr,
        outputs: result.outputs,
        webWorker: worker
    };
}
export default runPipeline;
//# sourceMappingURL=runPipeline.js.map