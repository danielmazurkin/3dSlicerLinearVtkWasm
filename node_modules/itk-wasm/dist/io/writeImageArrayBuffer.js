import createWebWorkerPromise from '../core/createWebWorkerPromise.js';
import config from '../itkConfig.js';
import InterfaceTypes from '../core/InterfaceTypes.js';
import getTransferable from '../core/getTransferable.js';
import castImage from '../core/castImage.js';
async function writeImageArrayBuffer(webWorker, image, fileName, options, useCompressionBackwardsCompatibility) {
    if (typeof image === 'boolean') {
        throw new Error('useCompression is now at the last argument position in itk-wasm');
    }
    let mimeType = '';
    if (typeof options === 'string') {
        mimeType = options;
    }
    let useCompression = false;
    if (typeof useCompressionBackwardsCompatibility === 'boolean') {
        useCompression = useCompressionBackwardsCompatibility;
    }
    if (typeof options === 'object' && typeof options.useCompression !== 'undefined') {
        useCompression = options.useCompression;
    }
    let worker = webWorker;
    const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise(worker);
    worker = usedWorker;
    const filePath = `./${fileName}`;
    const args = ['0', filePath, '--memory-io', '--quiet'];
    if (useCompression) {
        args.push('--use-compression');
    }
    const outputs = [
        { data: { path: filePath }, type: InterfaceTypes.BinaryFile }
    ];
    let inputImage = image;
    if (typeof options === 'object' && (typeof options.componentType !== 'undefined' || typeof options.pixelType !== 'undefined')) {
        inputImage = castImage(image, options);
    }
    const inputs = [
        { type: InterfaceTypes.Image, data: inputImage }
    ];
    const transferables = [];
    let transferable = getTransferable(image.data);
    if (transferable != null) {
        transferables.push(transferable);
    }
    transferable = getTransferable(image.direction);
    if (transferable != null) {
        transferables.push(transferable);
    }
    const result = await webworkerPromise.postMessage({
        operation: 'writeImage',
        config: config,
        mimeType,
        fileName,
        pipelinePath: 'WriteImage',
        args,
        outputs,
        inputs
    }, transferables);
    return { arrayBuffer: result.outputs[0].data.data.buffer, webWorker: worker };
}
export default writeImageArrayBuffer;
//# sourceMappingURL=writeImageArrayBuffer.js.map